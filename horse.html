<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>Horse Model Demo</title>

<script type="text/javascript" src="three.min.js"></script>
<script type="text/javascript">

// define these in init
var renderer;  // three js rendered; could be webgl or canvas renderer
var scene;     // 3d scene rendered from perspective of camera; contains model/objects
var camera;    // the camera thru which perspective we see the scene


var model; // three js object that is the  3d model

var rotateX = 0;   // rotation of model about the x-axis would have to call in animate()
var rotateY = 0;  // rotation of model about the y-axis


// light is added to the scene; createLight in init()
function createLight() {
    var light = light = new THREE.DirectionalLight()
    light.position.set(0,0,10) // light fron different sides
    scene.add(light)
}
// light

/**
 * The callback function that is called by the JSONLoader when it
 * has finished loading the object.  This function creates a three.js
 * function to hold the object.  It translates the object so that
 * its center is in the origin.  It wraps the object in another object
 * that is used to scale and rotate the object.  The scale is set
 * so that the maximum coordinate in its vertices, in absolute
 * value, is scaled to 10.  The rotation is controlled by the arrow
 * keys.
 */
function modelLoadedCallback(geometry, materials) {

    /* create the object from the geometry and materials that were loaded.  There
       can be multiple materials, which can be applied to the object using MeshFaceMaterials.
       Note tha the material can include references to texture images might finish
       loading later. */

    var object = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(materials));

    /* Determine the ranges of x, y, and z in the vertices of the geometry. */

    var xmin = Infinity;
    var xmax = -Infinity;
    var ymin = Infinity;
    var ymax = -Infinity;
    var zmin = Infinity;
    var zmax = -Infinity;
    for (var i = 0; i < geometry.vertices.length; i++) {
        var v = geometry.vertices[i];
        if (v.x < xmin)
            xmin = v.x;
        else if (v.x > xmax)
            xmax = v.x;
        if (v.y < ymin)
            ymin = v.y;
        else if (v.y > ymax)
            ymax = v.y;
        if (v.z < zmin)
            zmin = v.z;
        else if (v.z > zmax)
            zmax = v.z;
    }

    /* translate the center of the object to the origin */
    var centerX = (xmin+xmax)/2;
    var centerY = (ymin+ymax)/2;
    var centerZ = (zmin+zmax)/2;
    var max = Math.max(centerX - xmin, xmax - centerX);
    max = Math.max(max, Math.max(centerY - ymin, ymax - centerY) );
    max = Math.max(max, Math.max(centerZ - zmin, zmax - centerZ) );
    var scale = 10/max;
    object.position.set( -centerX, -centerY, -centerZ );
    console.log("Loading finished, scaling object by " + scale);
    console.log("Center at ( " + centerX + ", " + centerY + ", " + centerZ + " )");

    /* Create the wrapper, model, to scale and rotate the object. */

    model = new THREE.Object3D();
    model.add(object);
    model.scale.set(scale,scale,scale);
    rotateX = rotateY = 0;
    scene.add(model);
    render();

}


// potentially use to load multiple models / black background color won't work for all
function installModel(file, bgColor) {
    if (model) {
        scene.remove(model);
    }
    renderer.setClearColor(bgColor);
    render();
    var loader = new THREE.JSONLoader();
    loader.load("models-json/" + file, modelLoadedCallback);
}



/**
 *  The render fucntion creates an image of the scene from the point of view
 *  of the camera and displays it in the canvas.  This is called at the end of
 *  init() to produce the initial view of the model, and it is called each time
 *  the user presses an arrow key, return, or home.
 */
function render() {
    renderer.render(scene, camera);
}

//
//  Keydown event listener in init()
//
function keyControl(evt) {
    var rotationChanged = true;
	switch (evt.keyCode) {
	    case 37: rotateY -= 0.05; break;        // left arrow
	    case 39: rotateY +=  0.05; break;       // right arrow
	    case 38: rotateX -= 0.05; break;        // up arrow
	    case 40: rotateX += 0.05; break;        // down arrow
	    case 13: rotateX = rotateY = 0; break;  // return
	    case 36: rotateX = rotateY = 0; break;  // home
	    default: rotationChanged = false;
	}
	if (model && rotationChanged) {
       model.rotation.set(rotateX,rotateY,0);
       render();
	   evt.preventDefault();
	}
}

// /**
//  *  This function is called by the onload event so it will run after the
//  *  page has loaded.  It creates the renderer, canvas, and scene objects,
//  *  calls createWorld() to add objects to the scene, and renders the
//  *  initial view of the scene.  If an error occurs, it is reported.
//  */
function init() {
    try {
        var theCanvas = document.getElementById("cnvs");

        renderer = new THREE.CanvasRenderer( { canvas: theCanvas } );
        renderer.setSize(theCanvas.width, theCanvas.height);

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(50, theCanvas.width/theCanvas.height, 0.1, 100);
        camera.position.z = 25;
        createLight()
        installModel("horse.js");
        render();
        document.addEventListener("keydown", keyControl, false)
     }
     catch (e) {
        console.log(e)
     }
}

</script>
</head>

<body onload="init()">

<h2>Horse Model Demo</h2>

<canvas width=1200 height=900 id="cnvs" style="background-color:black"></canvas>


</body>
</html>
